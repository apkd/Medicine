using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

#pragma warning disable CS9113

/// <summary>
/// A utility class for generating and formatting source code text.
/// Uses pooled string builders and an interpolated string handler to minimize heap allocations.
/// </summary>
public sealed class SourceWriter : IDisposable
{
    const int INDENT_SIZE = 4;

    readonly StringBuilder stringBuilder
        = StringBuilderPool.Rent()
            .AppendLine("// <auto-generated/>")
            .AppendLine("#nullable enable");

    int indent;

    /// <summary>
    /// Writes an interpolated string to the source output.
    /// </summary>
    public SourceWriter Write(
        // ReSharper disable once UnusedParameter.Global
        [InterpolatedStringHandlerArgument("")]
        Interpolation value
    ) => this;

    /// <summary>
    /// Writes a string to the source output.
    /// </summary>
    public SourceWriter Write(string? text)
    {
        stringBuilder.Append(text);
        return this;
    }

    /// <summary>
    /// Writes a single character to the source output.
    /// </summary>
    public SourceWriter Write(char character)
    {
        stringBuilder.Append(character);
        return this;
    }

    /// <summary>
    /// Removes any trailing whitespace characters from the internal string buffer.
    /// </summary>
    public void TrimEndWhitespace()
    {
        while (char.IsWhiteSpace(stringBuilder[^1]))
            stringBuilder.Remove(stringBuilder.Length - 1, 1);
    }

    /// <summary>
    /// Inserts a linebreak into the source output, ensuring the current output ends
    /// with a newline character (but only if it does not already).
    /// </summary>
    public void Linebreak()
    {
        if (stringBuilder.Length is var n and >= 1)
            if (stringBuilder[n - 1] != '\n')
                stringBuilder.AppendLine();
    }

    /// <summary>
    /// This property appends a line break followed by spaces, equivalent to the
    /// current indentation level, to prepare for writing a new line of content.
    /// </summary>
    public SourceWriter Line
    {
        get
        {
            stringBuilder.AppendLine().Append(' ', indent);
            return this;
        }
    }

    /// <summary>
    /// Appends a linebreak, writes an opening brace to the source output,
    /// and increases the current indentation level.
    /// </summary>
    public void OpenBrace()
    {
        Line.Write('{');
        IncreaseIndent();
    }

    /// <summary>
    /// Trims trailing whitespace, writes a closing brace to the source output,
    /// and decreases the indentation level.
    /// </summary>
    public void CloseBrace()
    {
        DecreaseIndent();
        TrimEndWhitespace();
        Line.Write('}');
    }

    /// <summary>
    /// Increases the current indentation level used for formatting the generated source output.
    /// </summary>
    public void IncreaseIndent()
        => indent += INDENT_SIZE;

    /// <summary>
    /// Decreases the current indentation level used for formatting the generated source output.
    /// </summary>
    public void DecreaseIndent()
        => indent -= INDENT_SIZE;

    /// <summary>
    /// Returns a disposable scope within which outputted code is indented.
    /// </summary>
    /// <example>
    /// using (src.Indent)
    /// {
    ///    // (code emitted here is indented)
    /// }
    /// </example>
    public IndentScope Indent
        => new(this);

    /// <summary>
    /// Returns a disposable scope within which outputted code is surrounded by braces and indented.
    /// </summary>
    /// <example>
    /// using (src.Braces)
    /// {
    ///    // (code emitted here is indented and surrounded by braces)
    /// }
    /// </example>
    public BracesScope Braces
        => new(this);

    /// <summary>
    /// Returns a string containing the generated source text.
    /// </summary>
    public override string ToString()
        => stringBuilder.ToString();

    void IDisposable.Dispose()
        => StringBuilderPool.Return(stringBuilder);

    [StructLayout((short)0, Size = 128)]
    public readonly ref struct IndentScope
    {
        readonly SourceWriter writer;

        public IndentScope(SourceWriter writer)
            => (this.writer = writer).IncreaseIndent();

        public void Dispose()
            => writer.DecreaseIndent();
    }

    public readonly ref struct BracesScope
    {
        readonly SourceWriter writer;

        public BracesScope(SourceWriter writer)
            => (this.writer = writer).OpenBrace();

        public void Dispose()
            => writer.CloseBrace();
    }

    [InterpolatedStringHandler]
    public readonly struct Interpolation(int literalLength, int formattedCount, SourceWriter writer)
    {
        public void AppendLiteral(string value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(string? value, string format)
        {
            switch (format)
            {
                case nameof(SplitGenericTypeName):
                    SplitGenericTypeName(value);
                    return;
            }

            writer.stringBuilder.Append(value);
        }

        public void AppendFormatted(string? value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(int value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(int value, string format)
            => writer.stringBuilder.Append(value.ToString(format));

        public void AppendFormatted(long value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(long value, string format)
            => writer.stringBuilder.Append(value.ToString(format));

        public void AppendFormatted(float value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(float value, string format)
            => writer.stringBuilder.Append(value.ToString(format));

        public void AppendFormatted(double value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(double value, string format)
            => writer.stringBuilder.Append(value.ToString(format));

        public void AppendFormatted(char value)
            => writer.stringBuilder.Append(value);

        public void AppendFormatted(bool value)
            => writer.stringBuilder.Append(value);

        void SplitGenericTypeName(string? typeName)
        {
            if (typeName is null)
                return;

            int tuple = 0;

            foreach (char ch in typeName.AsSpan())
            {
                switch (ch)
                {
                    case '<':
                        writer.Write(ch);
                        writer.IncreaseIndent();
                        writer.Line.Write("");
                        continue;

                    case '>':
                        writer.Write(ch);
                        writer.DecreaseIndent();
                        continue;

                    case ',':
                        writer.Write(ch);
                        writer.Line.Write("");
                        continue;

                    case ' ':
                        if (tuple > 0)
                            goto default;

                        continue;

                    case '(':
                        tuple += 1;
                        goto default;

                    case ')':
                        tuple -= 1;
                        goto default;

                    default:
                        writer.Write(ch);
                        continue;
                }
            }
        }
    }
}