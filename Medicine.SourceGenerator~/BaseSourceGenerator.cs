using System.Collections.Concurrent;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

public interface IGeneratorInput
{
    string? SourceGeneratorOutputFilename { get; }
    CacheIgnore<List<string>> SourceGeneratorDiagnostics { get; set; }
    string SourceGeneratorError { get; set; }
}

public abstract class BaseSourceGenerator
{
    const int INDENT_SIZE = 4;
    readonly StringBuilder text = new(capacity: 16384);
    int indent;
    static readonly ConcurrentDictionary<(string, string, int), int> invokationCounter = new();

    protected void HandleException<TInput>(SourceProductionContext context, TInput input) where TInput : IGeneratorInput { }

    protected static Func<GeneratorAttributeSyntaxContext, CancellationToken, TOutput> WrapTransform<TOutput>(
        Func<GeneratorAttributeSyntaxContext, CancellationToken, TOutput> action,
        [CallerArgumentExpression("action")] string? cae = null,
        [CallerFilePath] string? cfp = null,
        [CallerLineNumber] int cln = 0
    )
        where TOutput : IGeneratorInput, new()
        => (context, ct) =>
        {
            try
            {
                var time = Stopwatch.StartNew();
                var result = action(context, ct);
                int count = invokationCounter.AddOrUpdate((result.SourceGeneratorOutputFilename!, cfp!, cln), 1, (k, v) => ++v);

                if (result.SourceGeneratorDiagnostics.Value is not { Count: > 0 })
                    result.SourceGeneratorDiagnostics = new(new(capacity: 2));

                result.SourceGeneratorDiagnostics.Value.Add($"// [{count}]: {time.Elapsed.TotalMilliseconds:0.00}ms");
                return result;
            }
            catch (Exception exception)
            {
                return new() { SourceGeneratorError = $"{exception}\nThrown in: {cae}" };
            }
        };

    protected Action<SourceProductionContext, TInput> WrapGenerateSource<TInput>(
        Action<SourceProductionContext, TInput> action,
        [CallerArgumentExpression("action")] string? cae = null,
        [CallerFilePath] string? cfp = null,
        [CallerLineNumber] int cln = 0
    )
        where TInput : IGeneratorInput
        => (context, input) =>
        {
            InitializeOutputSourceText();
            if (input.SourceGeneratorError is not { Length: > 0 } error)
            {
                try
                {
                    var time = Stopwatch.StartNew();
                    action(context, input);
                    int count = invokationCounter.AddOrUpdate((input.SourceGeneratorOutputFilename!, cfp!, cln), 1, (k, v) => ++v);
                    input.SourceGeneratorDiagnostics.Value.Add($"// {cae!}[{count}]: {time.Elapsed.TotalMilliseconds:0.00}ms");

                    if (input.SourceGeneratorDiagnostics.Value is { Count: > 0 })
                        Line.Append("// Diagnostics:");

                    foreach (var line in input.SourceGeneratorDiagnostics.Value)
                        Line.Append(line);

                    context.AddSource(input.SourceGeneratorOutputFilename!, FinalizeOutputSourceText());
                    return;
                }
                catch (Exception exception)
                {
                    error = $"{exception}\nThrown in: {cae}";
                }
            }

#if DEBUG
            foreach (var line in error.Split('\n', '\r').Where(x => x is { Length: > 0 }))
                Line.Append("#error ").Append(line);
#endif

            context.AddSource(input.SourceGeneratorOutputFilename ?? "Exception.g.cs", FinalizeOutputSourceText());
        };

    protected static string GetOutputFilename(string filePath, string targetFQN, string label)
    {
        string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(filePath);
        string typename = new string(targetFQN.Select(x => char.IsLetterOrDigit(x) ? x : '_').ToArray());
        var result = $"{fileNameWithoutExtension}.{typename}.{label}.{Hash():x8}.g.cs";
        Debug.WriteLine(result);
        return result;

        int Hash()
        {
            unchecked
            {
                int hash = 23;

                foreach (char c in fileNameWithoutExtension)
                    hash = hash * 31 + c;

                foreach (char c in targetFQN)
                    hash = hash * 31 + c;

                return hash;
            }
        }
    }

    protected void InitializeOutputSourceText()
    {
        indent = 0;
        text.Clear()
            .AppendLine("// <auto-generated/>")
            .AppendLine("#nullable enable");
    }

    protected SourceText FinalizeOutputSourceText()
    {
        string output = text.AppendLine().ToString();
        text.Clear();
        indent = 0;
        return SourceText.From(output, Encoding.UTF8);
    }

    public StringBuilder Append(string x)
        => text.Append(x);

    public StringBuilder Append(char x)
        => text.Append(x);

    protected void TrimEndWhitespace()
    {
        while (char.IsWhiteSpace(text[^1]))
            text.Remove(text.Length - 1, 1);
    }

    protected void Linebreak()
    {
        if (text.Length is var n and >= 1)
            if (text[n - 1] != '\n')
                text.AppendLine();
    }

    protected StringBuilder Line
        => text.AppendLine().Append(' ', indent);

    protected static bool MatchFilePath(ReadOnlySpan<char> filePath, ReadOnlySpan<char> subString1, ReadOnlySpan<char> substring2)
        => filePath.Contains(subString1, StringComparison.Ordinal) ||
           filePath.Contains(substring2, StringComparison.Ordinal);

    protected void OpenBrace()
    {
        Line.Append('{');
        IncreaseIndent();
    }

    protected void CloseBrace()
    {
        DecreaseIndent();
        TrimEndWhitespace();
        Line.Append('}');
    }

    protected void IncreaseIndent()
        => indent += INDENT_SIZE;

    protected void DecreaseIndent()
        => indent -= INDENT_SIZE;

    protected IndentScope Indent
        => new(this);

    protected BracesScope Braces
        => new(this);

    protected readonly struct IndentScope : IDisposable
    {
        readonly BaseSourceGenerator generator;

        public IndentScope(BaseSourceGenerator generator)
            => (this.generator = generator).IncreaseIndent();

        public void Dispose()
            => generator.DecreaseIndent();
    }

    protected readonly struct BracesScope : IDisposable
    {
        readonly BaseSourceGenerator generator;

        public BracesScope(BaseSourceGenerator generator)
            => (this.generator = generator).OpenBrace();

        public void Dispose()
            => generator.CloseBrace();
    }
}