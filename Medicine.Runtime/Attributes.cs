#nullable enable
#define MEDICINE_V3_MIGRATION
using System;
using System.ComponentModel;
using JetBrains.Annotations;
using static System.AttributeTargets;
using static System.ComponentModel.EditorBrowsableState;
using static JetBrains.Annotations.ImplicitUseTargetFlags;

[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Medicine.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Medicine.Tests.EditMode")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Medicine.Tests.PlayMode")]

// ReSharper disable MemberHidesStaticFromOuterClass
// ReSharper disable UnusedType.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable GrammarMistakeInComment

namespace Medicine
{
    /// <summary>
    /// Configures default settings for various Medicine features at the assembly level.
    /// Some of these settings can be overridden at the class or method level using attributes.
    /// </summary>
    [AttributeUsage(Assembly)]
    public sealed class MedicineSettingsAttribute : Attribute
    {
        /// <param name="makePublic">
        /// Configures whether properties generated by the <see cref="InjectAttribute"/> are public by default.
        /// </param>
        /// <param name="singletonStrategy">
        /// Configures singleton registration and conflict management options for classes marked with <see cref="SingletonAttribute"/>.
        /// </param>
        /// <param name="debug">
        /// Certain debug features in the generated code, such as null checks, are stripped from release builds.
        /// By default, they are only available in debug builds and in the editor.
        /// This parameter lets you override this and force debugging to be always on or off.
        /// </param>
        public MedicineSettingsAttribute(
            bool makePublic = true,
            SingletonAttribute.Strategy singletonStrategy = SingletonAttribute.Strategy.Replace,
            DebugMode debug = DebugMode.Automatic
        ) { }

        [EditorBrowsable(Never)]
        public enum DebugMode
        {
            /// <summary>
            /// Automatically enable debugging in the editor and in debug builds
            /// and disable it in release builds. This is the default and recommended setting.
            /// </summary>
            Automatic = 0,

            /// <summary>
            /// Always enable debug-mode code generation.
            /// Useful for debugging issues with release builds.
            /// </summary>
            ForceEnabled = 1,

            /// <summary>
            /// Always disable debug-mode code generation.
            /// Useful for previewing the optimized code
            /// </summary>
            ForceDisabled = 2,
        }
    }

    /// <summary>
    /// The `[Inject]` attribute can be placed on any method to generate
    /// properties for any assignments in that method.
    /// </summary>
    /// <remarks>
    /// To use this feature, simply mark a method with <c>[Inject]</c> and write some
    /// assignments like in the example below.
    /// The source generator will automatically generate backing fields,
    /// null checks, etc. based on your code.
    /// </remarks>
    /// <example><code>
    /// [Inject]
    /// void Awake()
    /// {
    ///     Colliders = GetComponentsInChildren&lt;Collider&gt;(includeInactive: true);
    ///     Rigidbody = GetComponent&lt;Rigidbody&gt;().Optional();
    ///     Manager = Find.Singleton&lt;GameManager&gt;();
    ///     AllEnemies = Enemy.Instances;
    /// }
    /// </code></example>
    [MeansImplicitUse]
    [AttributeUsage(
        Method
#if MEDICINE_V3_MIGRATION
        | Property
#endif
    )]
    public sealed class InjectAttribute : Attribute
    {
        /// <param name="makePublic">
        /// Whether the generated properties should have public getters.
        /// </param>
        public InjectAttribute(bool makePublic = true) { }

        [Obsolete("This property exists for migration only."), EditorBrowsable(Never)]
        public bool Optional { get; set; }
    }

    [AttributeUsage(Class | Interface)]
    public sealed class SingletonAttribute : Attribute
    {
        /// <param name="strategy">
        /// Configures various singleton registration and conflict management options.
        /// This is a flag-based enum, so you can combine multiple options using bitwise OR.<br/>
        /// <b>Specifying this on a class overrides the global settings
        /// set by the <see cref="MedicineSettingsAttribute"/>.</b>
        /// </param>
        /// <param name="manual">
        /// Setting this to <c>true</c> disables automatic tracking - you'll need to invoke <c>RegisterTracked()</c>
        /// and <c>UnregisterTracked()</c> manually.
        /// </param>
        public SingletonAttribute(
            Strategy strategy = default,
            bool manual = false
        ) { }

        /// <summary>
        /// Defines how singleton conflicts should be resolved.
        /// This lets you customize the behavior when a singleton is registered while some
        /// other instance is still active.
        /// </summary>
        [Flags]
        public enum Strategy : uint
        {
            /// <summary>
            /// <b>Conflict resolution strategy:</b><br/>
            /// Replace the existing instance with the new one.
            /// (Last registration wins.)
            /// </summary>
            /// <remarks>This is the default behavior.</remarks>
            Replace = 0,

            /// <summary>
            /// <b>Conflict resolution strategy:</b><br/>
            /// Keep the existing instance.
            /// (First registration wins.)
            /// </summary>
            KeepExisting = 1 << 0,

            /// <summary>
            /// <b>Conflict resolution strategy:</b><br/>
            /// Throw an exception when a singleton is registered while another instance is active.
            /// This is the nuclear "fail fast" option - use it if you want to treat this as an unrecoverable error.
            /// </summary>
            ThrowException = 1 << 1,

            /// <summary>
            /// <b>Conflict resolution option:</b><br/>
            /// Log a warning message when a singleton is registered while another instance is active.
            /// </summary>
            LogWarning = 1 << 2,

            /// <summary>
            /// <b>Conflict resolution option:</b><br/>
            /// Log an error message when a singleton is registered while another instance is active.
            /// </summary>
            LogError = 1 << 3,

            /// <summary>
            /// <b>Conflict resolution option:</b><br/>
            /// Destroy the other instance (the old one or the new one, depending on the strategy).
            /// </summary>
            /// <remarks>Will not destroy assets.</remarks>
            Destroy = 1 << 4,

            /// <summary>
            /// <b>Option:</b><br/>
            /// Automatically instantiate the singleton on first access. The singleton instance is created by
            /// the registration system, and lasts for the lifetime of the application (unless replaced - see <see cref="Replace"/>).
            /// <br/><br/>
            /// Behavior depends on class type:
            /// <list type="bullet">
            /// <item>MonoBehaviours: Creates a GameObject marked with DontDestroyOnLoad and adds the component.</item>
            /// <item>ScriptableObjects: Instantiates an in-memory scriptable object.</item>
            /// </list>
            /// </summary>
            AutoInstantiate = 1 << 5,

            Default = Replace,
            Recommended = Replace | LogError,
        }
    }

    /// <summary>
    /// Instructs the code generator to extend the class to track a list of active instances.
    /// </summary>
    /// <remarks>
    /// <list type="bullet">
    /// <item>Use <see cref="Find.Instances{T}"/> to get access to the tracked instances. Works best with <c>foreach</c>.</item>
    /// <item>Install <see href="https://github.com/Cysharp/ZLinq">ZLinq</see> to query components with a GC-free, LINQ-like syntax.</item>
    /// <item>The source generator emits additional code that registers the class in <c>OnEnable</c>/<c>OnDisable</c>.</item>
    /// <item>(Actually, it uses the mostly-unknown <c>OnEnableINTERNAL</c>/<c>OnDisableINTERNAL</c>,
    /// which prevents conflicts with the rest of your code.)</item>
    /// <item>Working with the job system? Enable <c>trackTransforms</c> to automatically add the
    /// GameObject's transform to a <see cref="UnityEngine.Jobs.TransformAccessArray"/>.</item>
    /// </list>
    /// </remarks>
    /// <example><code>
    /// [Track]
    /// class MyComponent { }
    /// ...
    /// foreach (var instance in MyComponent.Instances)
    ///     Debug.Log(instance.name);
    /// </code></example>
    [AttributeUsage(Class | Interface)]
    public sealed class TrackAttribute : Attribute
    {
        /// <param name="transformAccessArray">
        /// Enables the automatic tracking of object transforms in a <see cref="UnityEngine.Jobs.TransformAccessArray"/>.
        /// </param>
        /// <param name="transformInitialCapacity">
        /// The starting size of the internal array used to track transform instances.
        /// </param>
        /// <param name="transformDesiredJobCount">
        /// A hint that tells the Job System how many parallel batches it should try to create when
        /// the <see cref="UnityEngine.Jobs.TransformAccessArray"/> is consumed by <see cref="UnityEngine.Jobs.IJobParallelForTransform"/>.
        /// (-1 = selected automatically)
        /// </param>
        /// <param name="cacheEnabledState">
        /// Caches the component's enabled state in a separate field.
        /// This makes it possible to check the component's enabled state without an expensive extern call.
        /// <br/>
        /// The generated <c>enabled</c> property effectively hides the built-in <see cref="UnityEngine.Behaviour.enabled"/>
        /// property, and tries to exactly replicate its behaviour.
        /// </param>
        /// <param name="manual">
        /// Setting this to <c>true</c> disables automatic tracking - you'll need to invoke <c>RegisterTracked()</c>
        /// and <c>UnregisterTracked()</c> manually.
        /// </param>
        public TrackAttribute(
            bool transformAccessArray = false,
            int transformInitialCapacity = 64,
            int transformDesiredJobCount = -1,
            bool cacheEnabledState = false,
            bool manual = false
        ) { }
    }

    /// <summary>
    /// Generates a set of structs and helpers that can be used to access class data
    /// in Burst-compiled code.
    /// </summary>
    /// <param name="includePrivate">Whether to include private members.</param>
    /// <param name="includePublic">Whether to include public members.</param>
    /// <param name="memberNames">Names of members to include in access.</param>
    /// <param name="safetyChecks">
    /// Enables/disables debug-only safety checks, for ensuring that accessed objects are not null/destroyed.
    /// Accessing a destroyed object will throw an exception.
    /// Safety checks are always disabled in release builds.<br/>
    /// If necessary, you should explicitly check whether an UnmanagedRef is destroyed
    /// using the <c>.IsValid()</c> extension, or using the generated
    /// <c>Access.IsValid</c> helper property.<br/>
    /// </param>
    public sealed class UnmanagedAccessAttribute : Attribute
    {
        public UnmanagedAccessAttribute(
            params string[] memberNames
        ) { }

        public UnmanagedAccessAttribute(
            bool safetyChecks = true,
            params string[] memberNames
        ) { }

        public UnmanagedAccessAttribute(
            bool includePrivate = true,
            bool includePublic = true,
            bool safetyChecks = true
        ) { }
    }

    /// <summary>
    /// Can be used to ensure that a mutable struct is not stored in a `readonly` field.
    /// This would prevent the struct's value from being updated.
    /// </summary>
    [AttributeUsage(Struct)]
    public sealed class DisallowReadonlyAttribute : Attribute { }

    namespace Internal
    {
        /// <summary>
        /// Used by source generators to mark which declaration triggered code generation for this property.
        /// You can use IDE navigation features to jump to the declaration site.
        /// </summary>
        [EditorBrowsable(Never)]
        [AttributeUsage(Property)]
        public sealed class DeclaredAtAttribute : Attribute
        {
            public DeclaredAtAttribute(string method = "", string property = "", string field = "", int line = 0) { }
        }
    }

    /// <summary>
    /// Marks the struct as the header for a tagged union,
    /// generating code to support class-like polymorphic methods and properties.
    /// Supports Burst compilation.
    /// </summary>
    [AttributeUsage(Struct)]
    [EditorBrowsable(Never)] // experimental feature - needs optimizations, analyzers etc
    public sealed class UnionHeaderAttribute : Attribute { }

    /// <summary>
    /// Marks the struct as one of the polymorphic structs defined for a <see cref="UnionHeaderAttribute"/>.
    /// </summary>
    [AttributeUsage(Struct)]
    [EditorBrowsable(Never)] // experimental feature - needs optimizations, analyzers etc
    public sealed class UnionAttribute : Attribute
    {
        public UnionAttribute(byte id = 0) { }
    }

    /// <summary>
    /// Marks the assembly for generation of a constants class containing Unity layers and tags
    /// extracted from <c>ProjectSettings/TagManager.asset</c>.
    /// </summary>
    /// <param name="namespace">
    /// Namespace of the generated constants class.
    /// </param>
    /// <param name="class">
    /// Name of the generated constants class.
    /// </param>
    /// <example>
    /// To enable this feature, put the attribute at the top of a file in your assembly:
    /// <code>[assembly: Medicine.GenerateUnityConstants]</code>
    /// Then you can reference the generated class, e.g.
    /// <code>
    /// gameObject.layer = (int)Constants.Layer.Default;
    /// bool hasTag = gameObject.CompareTag(Constants.Tag.Player);
    /// </code>
    /// </example>
    [AttributeUsage(Assembly)]
    public sealed class GenerateUnityConstantsAttribute : Attribute
    {
        public GenerateUnityConstantsAttribute(string @namespace = "Medicine", string @class = "Constants") { }
    }

#if MODULE_ZLINQ
    [AttributeUsage(Method | Property)]
    public sealed class WrapValueEnumerableAttribute : Attribute { }
#endif

#if MEDICINE_V3_MIGRATION
    [MeansImplicitUse, UsedImplicitly(WithMembers)]
    public static class Inject
    {
        [MeansImplicitUse, AttributeUsage(Property), EditorBrowsable(Never)]
        public sealed class FromChildren : Attribute
        {
            public bool Optional { get; set; }
            public bool IncludeInactive { get; set; }

            [MeansImplicitUse, AttributeUsage(Property), EditorBrowsable(Never)]
            public sealed class Lazy : Attribute
            {
                public bool IncludeInactive { get; set; }
            }
        }

        [MeansImplicitUse, AttributeUsage(Property), EditorBrowsable(Never)]
        public sealed class FromParents : Attribute
        {
            public bool Optional { get; set; }
            public bool IncludeInactive { get; set; }

            [MeansImplicitUse]
            [AttributeUsage(Property)]
            [EditorBrowsable(Never)]
            public sealed class Lazy : Attribute
            {
                public bool IncludeInactive { get; set; }
            }
        }

        [MeansImplicitUse, AttributeUsage(Property), EditorBrowsable(Never)]
        public sealed class Lazy : Attribute { }

        [MeansImplicitUse, AttributeUsage(Property), EditorBrowsable(Never)]
        public sealed class Single : Attribute { }

        [MeansImplicitUse, AttributeUsage(Property), EditorBrowsable(Never)]
        public sealed class All : Attribute { }
    }
#endif
}
